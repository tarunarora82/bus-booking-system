<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Production Bus Booking System - Comprehensive Test Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .test-section {
            margin: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border-left: 5px solid #007bff;
        }
        
        .test-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-icon {
            font-size: 1.2em;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .test-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .test-card h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1.1em;
        }
        
        .test-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin: 10px 0;
            display: inline-block;
        }
        
        .status-pending { background: #e2e3e5; color: #6c757d; }
        .status-running { background: #fff3cd; color: #856404; }
        .status-pass { background: #d4edda; color: #155724; }
        .status-fail { background: #f8d7da; color: #721c24; }
        
        .test-description {
            color: #6c757d;
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .test-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        
        .test-result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            min-height: 60px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .result-success { background: #d4edda; border-color: #c3e6cb; color: #155724; }
        .result-error { background: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .result-info { background: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
        
        .summary-section {
            margin: 30px;
            background: #fff;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #28a745;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .architecture-info {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .api-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9em;
        }
        
        .api-table th, .api-table td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        
        .api-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        
        .api-table code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.85em;
        }
        
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.85em;
            border-left: 4px solid #007bff;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Production Bus Booking System</h1>
            <p>Comprehensive Test Suite - Unified API Architecture</p>
            <p style="font-size: 1em; opacity: 0.8;">Testing: <code>backend/api/production-api.php</code></p>
        </div>

        <div class="architecture-info">
            <h3>üèóÔ∏è System Architecture Overview</h3>
            <p><strong>Unified API Endpoint:</strong> All requests route through <code>production-api.php</code></p>
            <p><strong>Supported Formats:</strong> REST endpoints (<code>/api/health</code>) + Legacy query style (<code>?action=health-check</code>)</p>
            <p><strong>Data Storage:</strong> JSON files in <code>/var/www/html/data/</code> with MySQL fallback</p>
            
            <table class="api-table">
                <thead>
                    <tr><th>Test Category</th><th>Endpoint Style</th><th>Purpose</th></tr>
                </thead>
                <tbody>
                    <tr><td>Health Check</td><td><code>GET /api/health</code></td><td>System availability</td></tr>
                    <tr><td>Bus Data</td><td><code>GET /api/buses/available</code></td><td>Available buses with real-time seats</td></tr>
                    <tr><td>Employee Lookup</td><td><code>GET /api/employee/bookings/{id}</code></td><td>Individual booking status</td></tr>
                    <tr><td>Booking Operations</td><td><code>POST /api/booking/create|cancel</code></td><td>Create/cancel bookings</td></tr>
                    <tr><td>Admin Functions</td><td><code>?action=admin-settings|admin-bookings</code></td><td>Admin management</td></tr>
                    <tr><td>Legacy Support</td><td><code>?action=available-buses</code></td><td>Backward compatibility</td></tr>
                </tbody>
            </table>
        </div>

        <div class="summary-section">
            <h3>üìä Test Execution Summary</h3>
            <div class="test-actions">
                <button class="btn btn-success" onclick="runAllTests()">üöÄ Run All Tests</button>
                <button class="btn btn-info" onclick="runCriticalTests()">‚ö° Run Critical Tests Only</button>
                <button class="btn btn-warning" onclick="clearAllResults()">üßπ Clear Results</button>
                <button class="btn btn-primary" onclick="exportResults()">üìÑ Export Results</button>
            </div>
            
            <div class="summary-stats">
                <div class="stat-card">
                    <div class="stat-number" id="total-tests">14</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="passed-tests">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="failed-tests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="success-rate">0%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            </div>
        </div>

        <!-- Core API Tests -->
        <div class="test-section">
            <h3><span class="test-icon">üîç</span> Core API Health & Infrastructure</h3>
            <div class="test-grid">
                <div class="test-card">
                    <h4>API Health Check</h4>
                    <div class="test-description">Verifies production API endpoint is responding and system is healthy</div>
                    <div class="test-status" id="status-health">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('health')">Test Health</button>
                    </div>
                    <div class="test-result" id="result-health"></div>
                </div>

                <div class="test-card">
                    <h4>Database Connection</h4>
                    <div class="test-description">Tests data storage connectivity and file system access</div>
                    <div class="test-status" id="status-database">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('database')">Test Database</button>
                    </div>
                    <div class="test-result" id="result-database"></div>
                </div>

                <div class="test-card">
                    <h4>API Endpoint Coverage</h4>
                    <div class="test-description">Validates all production API endpoints are accessible</div>
                    <div class="test-status" id="status-endpoints">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('endpoints')">Test Endpoints</button>
                    </div>
                    <div class="test-result" id="result-endpoints"></div>
                </div>
            </div>
        </div>

        <!-- Bus Management Tests -->
        <div class="test-section">
            <h3><span class="test-icon">üöå</span> Bus Management & Availability</h3>
            <div class="test-grid">
                <div class="test-card">
                    <h4>Bus Availability Data</h4>
                    <div class="test-description">Tests bus listing with real-time seat availability</div>
                    <div class="test-status" id="status-buses">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('buses')">Test Buses</button>
                    </div>
                    <div class="test-result" id="result-buses"></div>
                </div>

                <div class="test-card">
                    <h4>Real-Time Updates</h4>
                    <div class="test-description">Verifies seat counts update correctly with bookings</div>
                    <div class="test-status" id="status-realtime">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('realtime')">Test Real-Time</button>
                    </div>
                    <div class="test-result" id="result-realtime"></div>
                </div>

                <div class="test-card">
                    <h4>Bus Route Information</h4>
                    <div class="test-description">Validates bus route data and scheduling information</div>
                    <div class="test-status" id="status-routes">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('routes')">Test Routes</button>
                    </div>
                    <div class="test-result" id="result-routes"></div>
                </div>
            </div>
        </div>

        <!-- Employee & Booking Tests -->
        <div class="test-section">
            <h3><span class="test-icon">üë§</span> Employee & Booking Management</h3>
            <div class="test-grid">
                <div class="test-card">
                    <h4>Employee Lookup</h4>
                    <div class="test-description">Tests employee booking status retrieval</div>
                    <div class="test-status" id="status-employee">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('employee')">Test Employee</button>
                    </div>
                    <div class="test-result" id="result-employee"></div>
                </div>

                <div class="test-card">
                    <h4>Booking Creation</h4>
                    <div class="test-description">Tests new booking creation process</div>
                    <div class="test-status" id="status-booking">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('booking')">Test Booking</button>
                    </div>
                    <div class="test-result" id="result-booking"></div>
                </div>

                <div class="test-card">
                    <h4>Booking Cancellation</h4>
                    <div class="test-description">Tests booking cancellation functionality</div>
                    <div class="test-status" id="status-cancellation">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('cancellation')">Test Cancellation</button>
                    </div>
                    <div class="test-result" id="result-cancellation"></div>
                </div>
            </div>
        </div>

        <!-- Admin & System Tests -->
        <div class="test-section">
            <h3><span class="test-icon">‚öôÔ∏è</span> Admin Functions & System Management</h3>
            <div class="test-grid">
                <div class="test-card">
                    <h4>Admin Settings</h4>
                    <div class="test-description">Tests admin configuration management</div>
                    <div class="test-status" id="status-admin-settings">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('admin-settings')">Test Settings</button>
                    </div>
                    <div class="test-result" id="result-admin-settings"></div>
                </div>

                <div class="test-card">
                    <h4>Admin Bookings</h4>
                    <div class="test-description">Tests admin booking management and reports</div>
                    <div class="test-status" id="status-admin-bookings">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('admin-bookings')">Test Admin</button>
                    </div>
                    <div class="test-result" id="result-admin-bookings"></div>
                </div>

                <div class="test-card">
                    <h4>System Configuration</h4>
                    <div class="test-description">Validates system settings and environment</div>
                    <div class="test-status" id="status-system">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('system')">Test System</button>
                    </div>
                    <div class="test-result" id="result-system"></div>
                </div>
            </div>
        </div>

        <!-- Advanced Tests -->
        <div class="test-section">
            <h3><span class="test-icon">üî¨</span> Advanced & Performance Tests</h3>
            <div class="test-grid">
                <div class="test-card">
                    <h4>Concurrent Bookings</h4>
                    <div class="test-description">Tests system under concurrent booking load</div>
                    <div class="test-status" id="status-concurrent">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('concurrent')">Test Concurrency</button>
                    </div>
                    <div class="test-result" id="result-concurrent"></div>
                </div>

                <div class="test-card">
                    <h4>Backward Compatibility</h4>
                    <div class="test-description">Tests legacy API query-style endpoints</div>
                    <div class="test-status" id="status-legacy">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('legacy')">Test Legacy</button>
                    </div>
                    <div class="test-result" id="result-legacy"></div>
                </div>

                <div class="test-card">
                    <h4>Error Handling</h4>
                    <div class="test-description">Validates proper error responses and edge cases</div>
                    <div class="test-status" id="status-errors">Pending</div>
                    <div class="test-actions">
                        <button class="btn btn-primary" onclick="runTest('errors')">Test Errors</button>
                    </div>
                    <div class="test-result" id="result-errors"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = '/api/api';
        let testResults = {};
        let testRunning = false;

        // Unified API call function - maps REST endpoints to production API actions
        async function apiCall(endpoint, method = 'GET', data = null) {
            // Map REST endpoints to production API actions
            const endpointMapping = {
                'health': 'health-check',
                'buses/available': 'available-buses',
                'booking/create': 'book-seat',
                'booking/cancel': 'cancel-booking',
                'employee/bookings': 'employee-bookings'
            };
            
            let action = endpointMapping[endpoint] || endpoint;
            let params = {};
            
            // Handle employee bookings with ID extraction
            if (endpoint.includes('employee/bookings/')) {
                action = 'employee-bookings';
                const parts = endpoint.split('/');
                params.employee_id = parts[2];
                // Extract query parameters from URL
                const urlParts = endpoint.split('?');
                if (urlParts[1]) {
                    const searchParams = new URLSearchParams(urlParts[1]);
                    searchParams.forEach((value, key) => {
                        params[key] = value;
                    });
                }
            }
            
            return await legacyApiCall(action, params, method, data);
        }

        // Legacy API call function with Intel proxy bypass
        async function legacyApiCall(action, params = {}, method = 'GET', data = null) {
            const url = new URL(`${API_BASE_URL}/production-api.php`, window.location.origin);
            url.searchParams.append('action', action);
            
            // Add params to URL for GET requests, or merge with data for POST
            if (method === 'GET') {
                Object.keys(params).forEach(key => {
                    url.searchParams.append(key, params[key]);
                });
            }

            const config = {
                method,
                headers: { 
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                }
            };
            
            if (method !== 'GET') {
                // For POST requests, merge params with data  
                const requestData = { ...params, ...data };
                config.body = JSON.stringify(requestData);
            }

            try {
                const response = await fetch(url, config);
                let result;
                try {
                    result = await response.json();
                } catch (e) {
                    result = { error: 'Invalid JSON response', response: await response.text() };
                }
                return { 
                    success: response.ok && response.status < 400, 
                    data: result, 
                    status: response.status 
                };
            } catch (error) {
                return { 
                    success: false, 
                    error: error.message,
                    status: 0
                };
            }
        }

        // Update test status and result display
        function updateTestStatus(testId, status, result = '') {
            const statusElement = document.getElementById(`status-${testId}`);
            const resultElement = document.getElementById(`result-${testId}`);
            
            if (statusElement) {
                statusElement.className = `test-status status-${status}`;
                statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            }
            
            if (resultElement && result) {
                resultElement.innerHTML = result;
                resultElement.className = `test-result ${status === 'pass' ? 'result-success' : status === 'fail' ? 'result-error' : 'result-info'}`;
            }
        }

        // Update summary statistics
        function updateSummary() {
            const totalTests = 14;
            const results = Object.values(testResults);
            const passedTests = results.filter(r => r === true).length;
            const failedTests = results.filter(r => r === false).length;
            const successRate = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;

            document.getElementById('passed-tests').textContent = passedTests;
            document.getElementById('failed-tests').textContent = failedTests;
            document.getElementById('success-rate').textContent = successRate + '%';
        }

        // Individual test functions
        async function testHealth() {
            updateTestStatus('health', 'running', '<div class="loading"></div> Testing API health...');
            
            try {
                const result = await apiCall('health');
                
                if (result.success && result.data.status === 'success') {
                    const resultHTML = `
                        <strong>‚úÖ API Health Check Passed</strong><br>
                        <strong>Message:</strong> ${result.data.message}<br>
                        <strong>Version:</strong> ${result.data.version}<br>
                        <strong>Timestamp:</strong> ${result.data.timestamp}<br>
                        <strong>Data Path:</strong> ${result.data.data_path}
                    `;
                    updateTestStatus('health', 'pass', resultHTML);
                    testResults.health = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'Health check failed');
                }
            } catch (error) {
                updateTestStatus('health', 'fail', `<strong>‚ùå Health Check Failed</strong><br>Error: ${error.message}`);
                testResults.health = false;
            }
            updateSummary();
        }

        async function testDatabase() {
            updateTestStatus('database', 'running', '<div class="loading"></div> Testing database connectivity...');
            
            try {
                // Test by trying to get admin settings (which creates default data)
                const result = await legacyApiCall('admin-settings');
                
                if (result.success && result.data.status === 'success') {
                    updateTestStatus('database', 'pass', `
                        <strong>‚úÖ Database Connection Successful</strong><br>
                        <strong>Status:</strong> Connected and operational<br>
                        <strong>Data Storage:</strong> JSON files accessible<br>
                        <strong>Default Data:</strong> Created successfully
                    `);
                    testResults.database = true;
                } else {
                    throw new Error(result.error || 'Database connection failed');
                }
            } catch (error) {
                updateTestStatus('database', 'fail', `<strong>‚ùå Database Test Failed</strong><br>Error: ${error.message}`);
                testResults.database = false;
            }
            updateSummary();
        }

        async function testEndpoints() {
            updateTestStatus('endpoints', 'running', '<div class="loading"></div> Testing API endpoints...');
            
            const endpoints = [
                { url: 'health', name: 'Health Check' },
                { url: 'buses/available', name: 'Bus Availability' }
            ];
            
            let passedEndpoints = 0;
            let results = [];
            
            try {
                for (const endpoint of endpoints) {
                    const result = await apiCall(endpoint.url);
                    if (result.success) {
                        passedEndpoints++;
                        results.push(`‚úÖ ${endpoint.name}: OK`);
                    } else {
                        results.push(`‚ùå ${endpoint.name}: Failed (${result.status})`);
                    }
                }
                
                if (passedEndpoints === endpoints.length) {
                    updateTestStatus('endpoints', 'pass', `
                        <strong>‚úÖ All API Endpoints Accessible</strong><br>
                        ${results.join('<br>')}
                    `);
                    testResults.endpoints = true;
                } else {
                    updateTestStatus('endpoints', 'fail', `
                        <strong>‚ö†Ô∏è Some Endpoints Failed</strong><br>
                        ${results.join('<br>')}<br>
                        <strong>Passed:</strong> ${passedEndpoints}/${endpoints.length}
                    `);
                    testResults.endpoints = false;
                }
            } catch (error) {
                updateTestStatus('endpoints', 'fail', `<strong>‚ùå Endpoint Test Failed</strong><br>Error: ${error.message}`);
                testResults.endpoints = false;
            }
            updateSummary();
        }

        async function testBuses() {
            updateTestStatus('buses', 'running', '<div class="loading"></div> Testing bus availability...');
            
            try {
                const result = await apiCall('buses/available');
                
                if (result.success && result.data.status === 'success' && result.data.data) {
                    const buses = result.data.data;
                    const busTable = buses.map(bus => 
                        `<tr><td>${bus.bus_number}</td><td>${bus.route}</td><td>${bus.capacity}</td><td>${bus.available_seats}</td></tr>`
                    ).join('');
                    
                    updateTestStatus('buses', 'pass', `
                        <strong>‚úÖ Bus Data Retrieved Successfully</strong><br>
                        <strong>Total Buses:</strong> ${buses.length}<br>
                        <table class="api-table">
                            <tr><th>Bus#</th><th>Route</th><th>Capacity</th><th>Available</th></tr>
                            ${busTable}
                        </table>
                    `);
                    testResults.buses = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'No bus data received');
                }
            } catch (error) {
                updateTestStatus('buses', 'fail', `<strong>‚ùå Bus Test Failed</strong><br>Error: ${error.message}`);
                testResults.buses = false;
            }
            updateSummary();
        }

        async function testEmployee() {
            updateTestStatus('employee', 'running', '<div class="loading"></div> Testing employee lookup...');
            
            try {
                const testEmployeeId = '11453732';
                const testDate = '2025-10-01';
                const result = await apiCall(`employee/bookings/${testEmployeeId}?date=${testDate}`);
                
                if (result.success && result.data.status === 'success') {
                    updateTestStatus('employee', 'pass', `
                        <strong>‚úÖ Employee Lookup Successful</strong><br>
                        <strong>Employee ID:</strong> ${result.data.employee_id}<br>
                        <strong>Message:</strong> ${result.data.message}<br>
                        <strong>Has Booking:</strong> ${result.data.has_booking ? 'Yes' : 'No'}<br>
                        <strong>Bookings Found:</strong> ${result.data.data ? result.data.data.length : 0}
                    `);
                    testResults.employee = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'Employee lookup failed');
                }
            } catch (error) {
                updateTestStatus('employee', 'fail', `<strong>‚ùå Employee Test Failed</strong><br>Error: ${error.message}`);
                testResults.employee = false;
            }
            updateSummary();
        }

        async function testBooking() {
            updateTestStatus('booking', 'running', '<div class="loading"></div> Testing booking creation...');
            
            try {
                const testData = {
                    employee_id: 'TEST' + Date.now(),
                    bus_number: 'BUS001',
                    schedule_date: '2025-10-01'
                };
                
                const result = await apiCall('booking/create', 'POST', testData);
                
                if (result.success && result.data.status === 'success') {
                    updateTestStatus('booking', 'pass', `
                        <strong>‚úÖ Booking Creation Successful</strong><br>
                        <strong>Booking ID:</strong> ${result.data.booking?.id}<br>
                        <strong>Employee:</strong> ${result.data.booking?.employee_id}<br>
                        <strong>Bus:</strong> ${result.data.booking?.bus_number}<br>
                        <strong>Date:</strong> ${result.data.booking?.schedule_date}<br>
                        <strong>Status:</strong> ${result.data.booking?.status}
                    `);
                    testResults.booking = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'Booking creation failed');
                }
            } catch (error) {
                updateTestStatus('booking', 'fail', `<strong>‚ùå Booking Test Failed</strong><br>Error: ${error.message}`);
                testResults.booking = false;
            }
            updateSummary();
        }

        async function testCancellation() {
            updateTestStatus('cancellation', 'running', '<div class="loading"></div> Testing booking cancellation...');
            
            try {
                // First create a booking to cancel
                const testData = {
                    employee_id: 'CANCEL_TEST' + Date.now(),
                    bus_number: 'BUS001',
                    schedule_date: '2025-10-01'
                };
                
                const createResult = await apiCall('booking/create', 'POST', testData);
                if (!createResult.success) {
                    throw new Error('Could not create test booking for cancellation');
                }
                
                // Now cancel it
                const cancelResult = await apiCall('booking/cancel', 'POST', testData);
                
                if (cancelResult.success && cancelResult.data.status === 'success') {
                    updateTestStatus('cancellation', 'pass', `
                        <strong>‚úÖ Booking Cancellation Successful</strong><br>
                        <strong>Create Result:</strong> ${createResult.data.message}<br>
                        <strong>Cancel Result:</strong> ${cancelResult.data.message}<br>
                        <strong>Flow:</strong> Create ‚Üí Cancel ‚Üí Success
                    `);
                    testResults.cancellation = true;
                } else {
                    throw new Error(cancelResult.error || cancelResult.data?.message || 'Cancellation failed');
                }
            } catch (error) {
                updateTestStatus('cancellation', 'fail', `<strong>‚ùå Cancellation Test Failed</strong><br>Error: ${error.message}`);
                testResults.cancellation = false;
            }
            updateSummary();
        }

        async function testAdminSettings() {
            updateTestStatus('admin-settings', 'running', '<div class="loading"></div> Testing admin settings...');
            
            try {
                const result = await legacyApiCall('admin-settings');
                
                if (result.success && result.data.status === 'success') {
                    const settings = result.data.data;
                    updateTestStatus('admin-settings', 'pass', `
                        <strong>‚úÖ Admin Settings Retrieved</strong><br>
                        <strong>SMTP Host:</strong> ${settings.smtp_host}<br>
                        <strong>SMTP Port:</strong> ${settings.smtp_port}<br>
                        <strong>Booking Cutoff:</strong> ${settings.booking_cutoff} minutes<br>
                        <strong>Max Advance Days:</strong> ${settings.max_advance_days}<br>
                        <strong>Real-time Interval:</strong> ${settings.real_time_interval} seconds
                    `);
                    testResults['admin-settings'] = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'Admin settings failed');
                }
            } catch (error) {
                updateTestStatus('admin-settings', 'fail', `<strong>‚ùå Admin Settings Test Failed</strong><br>Error: ${error.message}`);
                testResults['admin-settings'] = false;
            }
            updateSummary();
        }

        async function testAdminBookings() {
            updateTestStatus('admin-bookings', 'running', '<div class="loading"></div> Testing admin bookings...');
            
            try {
                const result = await legacyApiCall('admin-bookings');
                
                if (result.success && result.data.status === 'success') {
                    const bookings = result.data.data || [];
                    updateTestStatus('admin-bookings', 'pass', `
                        <strong>‚úÖ Admin Bookings Retrieved</strong><br>
                        <strong>Total Bookings:</strong> ${bookings.length}<br>
                        <strong>Recent Bookings:</strong> Last ${Math.min(bookings.length, 20)} shown<br>
                        <strong>Data Access:</strong> Administrative view working
                    `);
                    testResults['admin-bookings'] = true;
                } else {
                    throw new Error(result.error || result.data?.message || 'Admin bookings failed');
                }
            } catch (error) {
                updateTestStatus('admin-bookings', 'fail', `<strong>‚ùå Admin Bookings Test Failed</strong><br>Error: ${error.message}`);
                testResults['admin-bookings'] = false;
            }
            updateSummary();
        }

        async function testRealtime() {
            updateTestStatus('realtime', 'running', '<div class="loading"></div> Testing real-time updates...');
            
            try {
                // Get initial bus data
                const initialResult = await apiCall('buses/available');
                if (!initialResult.success) throw new Error('Could not get initial bus data');
                
                const initialBuses = initialResult.data.data;
                const testBus = initialBuses.find(bus => bus.bus_number === 'BUS001');
                if (!testBus) throw new Error('Test bus BUS001 not found');
                
                const initialSeats = testBus.available_seats;
                
                // Create a test booking
                const bookingData = {
                    employee_id: 'REALTIME_TEST' + Date.now(),
                    bus_number: 'BUS001',
                    schedule_date: new Date().toISOString().split('T')[0]
                };
                
                const bookingResult = await apiCall('booking/create', 'POST', bookingData);
                if (!bookingResult.success) throw new Error('Could not create test booking');
                
                // Get updated bus data
                const updatedResult = await apiCall('buses/available');
                if (!updatedResult.success) throw new Error('Could not get updated bus data');
                
                const updatedBuses = updatedResult.data.data;
                const updatedTestBus = updatedBuses.find(bus => bus.bus_number === 'BUS001');
                const updatedSeats = updatedTestBus.available_seats;
                
                // Clean up - cancel the test booking
                await apiCall('booking/cancel', 'POST', bookingData);
                
                if (updatedSeats < initialSeats) {
                    updateTestStatus('realtime', 'pass', `
                        <strong>‚úÖ Real-time Updates Working</strong><br>
                        <strong>Initial Available Seats:</strong> ${initialSeats}<br>
                        <strong>After Booking:</strong> ${updatedSeats}<br>
                        <strong>Seat Reduction:</strong> ${initialSeats - updatedSeats}<br>
                        <strong>Real-time Response:</strong> Immediate update confirmed
                    `);
                    testResults.realtime = true;
                } else {
                    throw new Error('Seat count did not update after booking');
                }
            } catch (error) {
                updateTestStatus('realtime', 'fail', `<strong>‚ùå Real-time Test Failed</strong><br>Error: ${error.message}`);
                testResults.realtime = false;
            }
            updateSummary();
        }

        async function testRoutes() {
            updateTestStatus('routes', 'running', '<div class="loading"></div> Testing bus routes...');
            
            try {
                const result = await apiCall('buses/available');
                
                if (result.success && result.data.data) {
                    const buses = result.data.data;
                    const routes = [...new Set(buses.map(bus => bus.route))];
                    const timeSlots = [...new Set(buses.map(bus => bus.slot))];
                    
                    updateTestStatus('routes', 'pass', `
                        <strong>‚úÖ Bus Route Information Valid</strong><br>
                        <strong>Available Routes:</strong> ${routes.join(', ')}<br>
                        <strong>Time Slots:</strong> ${timeSlots.join(', ')}<br>
                        <strong>Total Buses:</strong> ${buses.length}<br>
                        <strong>Route Coverage:</strong> ${routes.length} different routes
                    `);
                    testResults.routes = true;
                } else {
                    throw new Error('No bus route data available');
                }
            } catch (error) {
                updateTestStatus('routes', 'fail', `<strong>‚ùå Routes Test Failed</strong><br>Error: ${error.message}`);
                testResults.routes = false;
            }
            updateSummary();
        }

        async function testSystem() {
            updateTestStatus('system', 'running', '<div class="loading"></div> Testing system configuration...');
            
            try {
                // Test health endpoint for system info
                const healthResult = await apiCall('health');
                
                if (healthResult.success) {
                    // Test settings for system configuration
                    const settingsResult = await legacyApiCall('admin-settings');
                    
                    if (settingsResult.success) {
                        updateTestStatus('system', 'pass', `
                            <strong>‚úÖ System Configuration Valid</strong><br>
                            <strong>API Version:</strong> ${healthResult.data.version}<br>
                            <strong>Data Path:</strong> ${healthResult.data.data_path}<br>
                            <strong>System Time:</strong> ${healthResult.data.timestamp}<br>
                            <strong>Configuration:</strong> Settings accessible<br>
                            <strong>Environment:</strong> Production ready
                        `);
                        testResults.system = true;
                    } else {
                        throw new Error('System settings not accessible');
                    }
                } else {
                    throw new Error('System health check failed');
                }
            } catch (error) {
                updateTestStatus('system', 'fail', `<strong>‚ùå System Test Failed</strong><br>Error: ${error.message}`);
                testResults.system = false;
            }
            updateSummary();
        }

        async function testConcurrent() {
            updateTestStatus('concurrent', 'running', '<div class="loading"></div> Testing concurrent operations...');
            
            try {
                // Create multiple concurrent API calls
                const promises = [
                    apiCall('health'),
                    apiCall('buses/available'),
                    legacyApiCall('admin-settings'),
                    apiCall('employee/bookings/11453732')
                ];
                
                const results = await Promise.all(promises);
                const successCount = results.filter(result => result.success).length;
                
                if (successCount === promises.length) {
                    updateTestStatus('concurrent', 'pass', `
                        <strong>‚úÖ Concurrent Operations Successful</strong><br>
                        <strong>Concurrent Requests:</strong> ${promises.length}<br>
                        <strong>Successful Responses:</strong> ${successCount}<br>
                        <strong>Failure Rate:</strong> 0%<br>
                        <strong>System Load:</strong> Handled without issues
                    `);
                    testResults.concurrent = true;
                } else {
                    updateTestStatus('concurrent', 'fail', `
                        <strong>‚ö†Ô∏è Some Concurrent Operations Failed</strong><br>
                        <strong>Success Rate:</strong> ${successCount}/${promises.length}<br>
                        <strong>Failed Requests:</strong> ${promises.length - successCount}
                    `);
                    testResults.concurrent = false;
                }
            } catch (error) {
                updateTestStatus('concurrent', 'fail', `<strong>‚ùå Concurrent Test Failed</strong><br>Error: ${error.message}`);
                testResults.concurrent = false;
            }
            updateSummary();
        }

        async function testLegacy() {
            updateTestStatus('legacy', 'running', '<div class="loading"></div> Testing backward compatibility...');
            
            try {
                const legacyTests = [
                    { action: 'health-check', name: 'Health Check' },
                    { action: 'available-buses', name: 'Available Buses' },
                    { action: 'admin-settings', name: 'Admin Settings' }
                ];
                
                let passedTests = 0;
                let results = [];
                
                for (const test of legacyTests) {
                    const result = await legacyApiCall(test.action);
                    if (result.success) {
                        passedTests++;
                        results.push(`‚úÖ ${test.name}: Compatible`);
                    } else {
                        results.push(`‚ùå ${test.name}: Failed`);
                    }
                }
                
                if (passedTests === legacyTests.length) {
                    updateTestStatus('legacy', 'pass', `
                        <strong>‚úÖ Backward Compatibility Confirmed</strong><br>
                        ${results.join('<br>')}<br>
                        <strong>Legacy Support:</strong> 100% compatible<br>
                        <strong>Query-style API:</strong> Fully functional
                    `);
                    testResults.legacy = true;
                } else {
                    updateTestStatus('legacy', 'fail', `
                        <strong>‚ö†Ô∏è Compatibility Issues Found</strong><br>
                        ${results.join('<br>')}<br>
                        <strong>Compatibility Rate:</strong> ${Math.round((passedTests/legacyTests.length)*100)}%
                    `);
                    testResults.legacy = false;
                }
            } catch (error) {
                updateTestStatus('legacy', 'fail', `<strong>‚ùå Legacy Test Failed</strong><br>Error: ${error.message}`);
                testResults.legacy = false;
            }
            updateSummary();
        }

        async function testErrors() {
            updateTestStatus('errors', 'running', '<div class="loading"></div> Testing error handling...');
            
            try {
                // Test various error conditions
                const errorTests = [
                    { test: 'Invalid endpoint', call: () => apiCall('invalid/endpoint') },
                    { test: 'Empty employee ID', call: () => apiCall('employee/bookings/') },
                    { test: 'Invalid action', call: () => legacyApiCall('invalid-action') }
                ];
                
                let properErrors = 0;
                let results = [];
                
                for (const errorTest of errorTests) {
                    try {
                        const result = await errorTest.call();
                        if (!result.success && (result.status === 404 || result.data?.status === 'error')) {
                            properErrors++;
                            results.push(`‚úÖ ${errorTest.test}: Proper error response`);
                        } else {
                            results.push(`‚ùå ${errorTest.test}: No error returned`);
                        }
                    } catch (error) {
                        properErrors++;
                        results.push(`‚úÖ ${errorTest.test}: Exception handled`);
                    }
                }
                
                if (properErrors === errorTests.length) {
                    updateTestStatus('errors', 'pass', `
                        <strong>‚úÖ Error Handling Working</strong><br>
                        ${results.join('<br>')}<br>
                        <strong>Error Response Rate:</strong> 100%<br>
                        <strong>System Stability:</strong> Maintained during errors
                    `);
                    testResults.errors = true;
                } else {
                    updateTestStatus('errors', 'fail', `
                        <strong>‚ö†Ô∏è Error Handling Issues</strong><br>
                        ${results.join('<br>')}<br>
                        <strong>Proper Errors:</strong> ${properErrors}/${errorTests.length}
                    `);
                    testResults.errors = false;
                }
            } catch (error) {
                updateTestStatus('errors', 'fail', `<strong>‚ùå Error Test Failed</strong><br>Error: ${error.message}`);
                testResults.errors = false;
            }
            updateSummary();
        }

        // Test execution functions
        async function runTest(testId) {
            if (testRunning) return;
            
            const testFunctions = {
                'health': testHealth,
                'database': testDatabase,
                'endpoints': testEndpoints,
                'buses': testBuses,
                'employee': testEmployee,
                'booking': testBooking,
                'cancellation': testCancellation,
                'admin-settings': testAdminSettings,
                'admin-bookings': testAdminBookings,
                'realtime': testRealtime,
                'routes': testRoutes,
                'system': testSystem,
                'concurrent': testConcurrent,
                'legacy': testLegacy,
                'errors': testErrors
            };
            
            if (testFunctions[testId]) {
                await testFunctions[testId]();
            }
        }

        async function runCriticalTests() {
            if (testRunning) return;
            testRunning = true;
            
            const criticalTests = ['health', 'database', 'endpoints', 'buses', 'employee', 'booking'];
            
            for (const testId of criticalTests) {
                await runTest(testId);
                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between tests
            }
            
            testRunning = false;
        }

        async function runAllTests() {
            if (testRunning) return;
            testRunning = true;
            
            // Clear previous results
            testResults = {};
            
            const allTests = [
                'health', 'database', 'endpoints', 'buses', 'employee', 'booking', 
                'cancellation', 'admin-settings', 'admin-bookings', 'realtime', 
                'routes', 'system', 'concurrent', 'legacy', 'errors'
            ];
            
            for (const testId of allTests) {
                await runTest(testId);
                await new Promise(resolve => setTimeout(resolve, 300)); // Small delay between tests
            }
            
            testRunning = false;
            
            // Show final summary
            setTimeout(() => {
                const totalTests = allTests.length;
                const passedTests = Object.values(testResults).filter(r => r === true).length;
                const successRate = Math.round((passedTests / totalTests) * 100);
                
                if (successRate === 100) {
                    alert(`üéâ All Tests Passed!\n\nSuccess Rate: ${successRate}%\nTotal Tests: ${totalTests}\nPassed: ${passedTests}\n\nProduction system is ready for deployment!`);
                } else if (successRate >= 80) {
                    alert(`‚ö†Ô∏è Most Tests Passed\n\nSuccess Rate: ${successRate}%\nTotal Tests: ${totalTests}\nPassed: ${passedTests}\nFailed: ${totalTests - passedTests}\n\nSystem is mostly functional with some issues to address.`);
                } else {
                    alert(`‚ùå Multiple Test Failures\n\nSuccess Rate: ${successRate}%\nTotal Tests: ${totalTests}\nPassed: ${passedTests}\nFailed: ${totalTests - passedTests}\n\nSystem needs attention before production deployment.`);
                }
            }, 1000);
        }

        function clearAllResults() {
            testResults = {};
            
            const testIds = [
                'health', 'database', 'endpoints', 'buses', 'employee', 'booking',
                'cancellation', 'admin-settings', 'admin-bookings', 'realtime',
                'routes', 'system', 'concurrent', 'legacy', 'errors'
            ];
            
            testIds.forEach(testId => {
                updateTestStatus(testId, 'pending', '');
            });
            
            updateSummary();
        }

        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                totalTests: 14,
                results: testResults,
                summary: {
                    passed: Object.values(testResults).filter(r => r === true).length,
                    failed: Object.values(testResults).filter(r => r === false).length,
                    successRate: Math.round((Object.values(testResults).filter(r => r === true).length / 14) * 100)
                }
            };
            
            const dataStr = JSON.stringify(results, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `bus-booking-test-results-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        // Auto-run health check on page load
        window.onload = () => {
            setTimeout(() => {
                testHealth();
            }, 1000);
        };
    </script>
</body>
</html>